---
output: github_document
    
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
library(ggpubr)
library(knitr)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# lcsm: An R Package for Latent Change Score Modeling

[![last-change](https://img.shields.io/badge/Last%20change-2020--02--17-brightgreen.svg)](https://github.com/milanwiedemann/lcsm)
[![Travis build status](https://travis-ci.org/milanwiedemann/lcsm.svg?branch=master)](https://travis-ci.org/milanwiedemann/lcsm)
[![Build status](https://ci.appveyor.com/api/projects/status/swwgfqdufr5xmxf2?svg=true)](https://ci.appveyor.com/project/milanwiedemann/lcsm)
[![lcsm-version](https://img.shields.io/badge/Version-0.0.6-brightgreen.svg)](https://github.com/milanwiedemann/lcsm) 

This package offers some helper functions to specify and analyse
univariate and bivariate latent change score models (LCSM) using
[lavaan](http://lavaan.ugent.be/) (Rosseel,
[2012](http://www.jstatsoft.org/v48/i02/)).
For details about this method see for example McArdle
([2009](http://www.annualreviews.org/doi/10.1146/annurev.psych.60.110707.163612)),
Ghisletta ([2012](https://doi.org/10.1080/10705511.2012.713275)), Grimm
et al. ([2012](https://doi.org/10.1080/10705511.2012.659627)), and
Grimm, Ram & Estabrook
([2017](https://www.guilford.com/books/Growth-Modeling/Grimm-Ram-Estabrook/9781462526062)).

I started working on this project to better understand how latent change
score modeling works. This package combines the strengths of other R
packages like [lavaan](http://lavaan.ugent.be/),
[broom](https://broom.tidyverse.org), and
[semPlot](https://cran.r-project.org/web/packages/semPlot/index.html) by
generating lavaan syntax that helps these packages work together. 

An interactive web application **[`shinychange`](https://milanwiedemann.shinyapps.io/shinychange)**
illustrates some functions of this package.
This is work in progress and feedback is very welcome!

## Installation

You can install the development version from [GitHub](https://github.com/milanwiedemann/lcsm) with:

``` r
# install.packages("devtools")
devtools::install_github("milanwiedemann/lcsm")
```
## Overview of the functions

The `lcsm` package contains the following functions that can be categorised into:

- Functions to generate [lavaan](http://lavaan.ugent.be/) syntax for different model specifications:
  - `specify_uni_lcsm()`: Generate syntax for univariate LCSM
  - `specify_bi_lcsm()`: Generate syntax for bivariate LCSM
  
- Functions to fit models using [lavaan](http://lavaan.ugent.be/):
  - `fit_uni_lcsm()`: Fit univariate LCSM
  - `fit_bi_lcsm()`: Fit bivariate LCSM
  
- Functions to extract results from models using [broom](https://broom.tidyverse.org/):
  - `extract_fit()`: Extract fit statistics
  - `extract_param()`: Extract estimated parameters
  
- Simulate data using [lavaan](http://lavaan.ugent.be/):
  - `sim_uni_lcsm()`: Simulate data by specifying parameters for a univariate LCSM
  - `sim_bi_lcsm()`: Simulate data by specifying parameters for a bivariate LCSM
  
- Helper functions:
  - `plot_lcsm()`: Visualise LCSM using [semPlot](http://sachaepskamp.com/semPlot)
  - `select_uni_cases()`: Select cases for analysis based on available scores on one construct
  - `select_bi_cases()`: Select cases for analysis based on available scores on two construct

## How to use `lcsm`

Here are a few examples how to use the `lcsm` package.

```{r}
# Load the package
library(lcsm)
```


### Visualise data

Longitudinal data can be visualised using the `plot_trajectories()` function.
Here only 30% of the data is visualised using the argument `random_sample_frac = 0.3`.
Only consecutive measures are connected by lines as specified in `connect_missing = FALSE`.

```{r, fig.width = 6, fig.height = 3.5, dpi = 300}
# Create plot for construct x
plot_x <- plot_trajectories(data = data_bi_lcsm,
                            id_var = "id", 
                            var_list = c("x1", "x2", "x3", "x4", "x5", 
                                         "x6", "x7", "x8", "x9", "x10"),
                            xlab = "Time", ylab = "X Score",
                            connect_missing = FALSE, 
                            random_sample_frac = 0.3)

# Create plot for construct y
plot_y <- plot_trajectories(data = data_bi_lcsm,
                            id_var = "id", 
                            var_list = c("y1", "y2", "y3", "y4", "y5", 
                                        "y6", "y7", "y8", "y9", "y10"),
                            xlab = "Time", ylab = "Y Score",
                            connect_missing = FALSE, 
                            random_sample_frac = 0.3)

# Arrange plots next to each other using patchwork
library(patchwork)
plot_x + plot_y + plot_annotation(tag_levels = 'A')
```

### Fit LCS models

In a first step the functions `specify_uni_lcsm()` and `specify_bi_lcsm()` are used to specify the lavaan syntax for a specific LCS model.
The functions `fit_uni_lcsm()` and `fit_bi_lcsm()` are running specifying the syntax before passing it on to lavaan.

The following table descibes some of the different model specifications that the `model` arguments can take.
More detail can be found in the help files `help(fit_uni_lcsm)`.

#### Fit univariate LCS models

|Model specification |Description                                                    |
|:-------------------|:--------------------------------------------------------------|
|alpha_constant      |Constant change factor                                         |
|beta                |Proportional change factor                                     |
|phi                 |Autoregression of change scores                                |


The example below shows how to specify a generic univariate latent change score model using the function `specify_uni_lcsm()`.
A table of the description of all parameters that can be estimated is shown [here](#overview-of-estimated-lcs-model-parameters).

```{r, eval=FALSE}
specify_uni_lcsm(timepoints = 5,
                 var = "x",  
                 change_letter = "g",
                 model = list(alpha_constant = TRUE, 
                              beta = TRUE, 
                              phi = TRUE))
```

<details>
<summary>Click here to see the <code>lavaan</code> syntax specified above.</summary>
<p>
```
# Specify latent true scores 
lx1 =~ 1 * x1 
lx2 =~ 1 * x2 
lx3 =~ 1 * x3 
lx4 =~ 1 * x4 
lx5 =~ 1 * x5 
# Specify mean of latent true scores 
lx1 ~ gamma_lx1 * 1 
lx2 ~ 0 * 1 
lx3 ~ 0 * 1 
lx4 ~ 0 * 1 
lx5 ~ 0 * 1 
# Specify variance of latent true scores 
lx1 ~~ sigma2_lx1 * lx1 
lx2 ~~ 0 * lx2 
lx3 ~~ 0 * lx3 
lx4 ~~ 0 * lx4 
lx5 ~~ 0 * lx5 
# Specify intercept of obseved scores 
x1 ~ 0 * 1 
x2 ~ 0 * 1 
x3 ~ 0 * 1 
x4 ~ 0 * 1 
x5 ~ 0 * 1 
# Specify variance of observed scores 
x1 ~~ sigma2_ux * x1 
x2 ~~ sigma2_ux * x2 
x3 ~~ sigma2_ux * x3 
x4 ~~ sigma2_ux * x4 
x5 ~~ sigma2_ux * x5 
# Specify autoregressions of latent variables 
lx2 ~ 1 * lx1 
lx3 ~ 1 * lx2 
lx4 ~ 1 * lx3 
lx5 ~ 1 * lx4 
# Specify latent change scores 
dx2 =~ 1 * lx2 
dx3 =~ 1 * lx3 
dx4 =~ 1 * lx4 
dx5 =~ 1 * lx5 
# Specify latent change scores means 
dx2 ~ 0 * 1 
dx3 ~ 0 * 1 
dx4 ~ 0 * 1 
dx5 ~ 0 * 1 
# Specify latent change scores variances 
dx2 ~~ 0 * dx2 
dx3 ~~ 0 * dx3 
dx4 ~~ 0 * dx4 
dx5 ~~ 0 * dx5 
# Specify constant change factor 
g2 =~ 1 * dx2 + 1 * dx3 + 1 * dx4 + 1 * dx5 
# Specify constant change factor mean 
g2 ~ alpha_g2 * 1 
# Specify constant change factor variance 
g2 ~~ sigma2_g2 * g2 
# Specify constant change factor covariance with the initial true score 
g2 ~~ sigma_g2lx1 * lx1
# Specify proportional change component 
dx2 ~ beta_x * lx1 
dx3 ~ beta_x * lx2 
dx4 ~ beta_x * lx3 
dx5 ~ beta_x * lx4 
# Specify autoregression of change score 
dx3 ~ phi_x * dx2 
dx4 ~ phi_x * dx3 
dx5 ~ phi_x * dx4 
```
</p>
</details>




The function `fit_uni_lcsm()` can be used to fit a univariate LCS model using the sample data set `data_uni_lcsm`.
This functions first writes the lavaan syntax specified in the `model` argument and passes it on to `lavaaan::lavaan()`.

```{r}
# Fit univariate latent change score model
fit_uni_lcsm(data = data_uni_lcsm, 
             var =  c("x1", "x2", "x3", "x4", "x5",
                      "x6", "x7", "x8", "x9", "x10"),
             model = list(alpha_constant = TRUE, 
                          beta = FALSE, 
                          phi = TRUE))
```

It is also possible to show the lavaan syntax that was created to fit the model by the function `specify_uni_lcsm()`.
The lavaan syntax includes comments describing some parts of the syntax in more detail.
To save the syntax in an object the argument `return_lavaan_syntax_string` has to be set to `TRUE`.
This object can be returned in an easy to read format using `cat(syntax)`, or as a simple string without the `cat()` function.

```{r, eval=FALSE}
# Fit univariate latent change score model
syntax <- fit_uni_lcsm(data = data_uni_lcsm, 
                       var =  c("x1", "x2", "x3", "x4", "x5",
                                "x6", "x7", "x8", "x9", "x10"),
                       model = list(alpha_constant = TRUE, 
                                    beta = FALSE, 
                                    phi = TRUE),
                      return_lavaan_syntax = TRUE,
                      return_lavaan_syntax_string = TRUE)

# Return lavaan syntax in easy to read format
cat(syntax)
```


<details>
<summary>Click here to see the lavaan syntax specified in <code>syntax</code>.</summary>
<p>
```
# Specify latent true scores 
lx1 =~ 1 * x1 
lx2 =~ 1 * x2 
lx3 =~ 1 * x3 
lx4 =~ 1 * x4 
lx5 =~ 1 * x5 
lx6 =~ 1 * x6 
lx7 =~ 1 * x7 
lx8 =~ 1 * x8 
lx9 =~ 1 * x9 
lx10 =~ 1 * x10 
# Specify mean of latent true scores 
lx1 ~ gamma_lx1 * 1 
lx2 ~ 0 * 1 
lx3 ~ 0 * 1 
lx4 ~ 0 * 1 
lx5 ~ 0 * 1 
lx6 ~ 0 * 1 
lx7 ~ 0 * 1 
lx8 ~ 0 * 1 
lx9 ~ 0 * 1 
lx10 ~ 0 * 1 
# Specify variance of latent true scores 
lx1 ~~ sigma2_lx1 * lx1 
lx2 ~~ 0 * lx2 
lx3 ~~ 0 * lx3 
lx4 ~~ 0 * lx4 
lx5 ~~ 0 * lx5 
lx6 ~~ 0 * lx6 
lx7 ~~ 0 * lx7 
lx8 ~~ 0 * lx8 
lx9 ~~ 0 * lx9 
lx10 ~~ 0 * lx10 
# Specify intercept of obseved scores 
x1 ~ 0 * 1 
x2 ~ 0 * 1 
x3 ~ 0 * 1 
x4 ~ 0 * 1 
x5 ~ 0 * 1 
x6 ~ 0 * 1 
x7 ~ 0 * 1 
x8 ~ 0 * 1 
x9 ~ 0 * 1 
x10 ~ 0 * 1 
# Specify variance of observed scores 
x1 ~~ sigma2_ux * x1 
x2 ~~ sigma2_ux * x2 
x3 ~~ sigma2_ux * x3 
x4 ~~ sigma2_ux * x4 
x5 ~~ sigma2_ux * x5 
x6 ~~ sigma2_ux * x6 
x7 ~~ sigma2_ux * x7 
x8 ~~ sigma2_ux * x8 
x9 ~~ sigma2_ux * x9 
x10 ~~ sigma2_ux * x10 
# Specify autoregressions of latent variables 
lx2 ~ 1 * lx1 
lx3 ~ 1 * lx2 
lx4 ~ 1 * lx3 
lx5 ~ 1 * lx4 
lx6 ~ 1 * lx5 
lx7 ~ 1 * lx6 
lx8 ~ 1 * lx7 
lx9 ~ 1 * lx8 
lx10 ~ 1 * lx9 
# Specify latent change scores 
dx2 =~ 1 * lx2 
dx3 =~ 1 * lx3 
dx4 =~ 1 * lx4 
dx5 =~ 1 * lx5 
dx6 =~ 1 * lx6 
dx7 =~ 1 * lx7 
dx8 =~ 1 * lx8 
dx9 =~ 1 * lx9 
dx10 =~ 1 * lx10 
# Specify latent change scores means 
dx2 ~ 0 * 1 
dx3 ~ 0 * 1 
dx4 ~ 0 * 1 
dx5 ~ 0 * 1 
dx6 ~ 0 * 1 
dx7 ~ 0 * 1 
dx8 ~ 0 * 1 
dx9 ~ 0 * 1 
dx10 ~ 0 * 1 
# Specify latent change scores variances 
dx2 ~~ 0 * dx2 
dx3 ~~ 0 * dx3 
dx4 ~~ 0 * dx4 
dx5 ~~ 0 * dx5 
dx6 ~~ 0 * dx6 
dx7 ~~ 0 * dx7 
dx8 ~~ 0 * dx8 
dx9 ~~ 0 * dx9 
dx10 ~~ 0 * dx10 
# Specify constant change factor 
g2 =~ 1 * dx2 + 1 * dx3 + 1 * dx4 + 1 * dx5 + 1 * dx6 + 1 * dx7 + 1 * dx8 + 1 * dx9 + 1 * dx10 
# Specify constant change factor mean 
g2 ~ alpha_g2 * 1 
# Specify constant change factor variance 
g2 ~~ sigma2_g2 * g2 
# Specify constant change factor covariance with the initial true score 
g2 ~~ sigma_g2lx1 * lx1
# Specify autoregression of change score 
dx3 ~ phi_x * dx2 
dx4 ~ phi_x * dx3 
dx5 ~ phi_x * dx4 
dx6 ~ phi_x * dx5 
dx7 ~ phi_x * dx6 
dx8 ~ phi_x * dx7 
dx9 ~ phi_x * dx8 
dx10 ~ phi_x * dx9 
```
</p>
</details>

#### Fit bivariate LCS models

The function `fit_bi_lcsm()` allowes to specify two univariate LCS models using the arguments `model_x` and `model_x`.
These two constructs can then be connected using the `coupling` argument. 
More details can be found in the help files `help(fit_bi_lcsm)`.

|Coupling specification |Description                                            |
|:----------------------|:------------------------------------------------------|
|coupling_piecewise     |Piecewise coupling parameters                          |
|coupling_piecewise_num |Changepoint of piecewise coupling parameters           |
|delta_con_xy           |Change score x (t) determined by true score y (t)      |
|delta_con_yx           |Change score y (t) determined by true score x (t)      |
|delta_lag_xy           |Change score x (t) determined by true score y (t-1)    |
|delta_lag_yx           |Change score y (t) determined by true score x (t-1)    |
|xi_con_xy              |Change score x (t) determined by change score y (t)    |
|xi_con_yx              |Change score y (t) determined by change score x (t)    |
|xi_lag_xy              |Change score x (t) determined by change score y (t-1)  |
|xi_lag_yx              |Change score y (t) determined by change score x (t-1)  |

```{r}
fit_bi_lcsm(data = data_bi_lcsm, 
            var_x = c("x1", "x2", "x3", "x4", "x5",
                      "x6", "x7", "x8", "x9", "x10"),
            var_y = c("y1", "y2", "y3", "y4", "y5", 
                      "y6", "y7", "y8", "y9", "y10"),
            model_x = list(alpha_constant = TRUE, 
                           beta = TRUE, 
                           phi = FALSE),
            model_y = list(alpha_constant = TRUE, 
                           beta = TRUE, 
                           phi = TRUE),
            coupling = list(delta_lag_xy = TRUE, 
                            xi_lag_yx = TRUE))
```

### Extract fit statistics and parmeters

The main underlying functions to extract parameters and fit statistics come from the `broom` package: `broom::tidy()` and `broom::glance()`. 
The functions `extract_param()` and `extract_fit()` offer some tools that I find helpful when running LCS models in R, for example:

-  `extract_param()`: only one row per estimated parameter,
- `extract_fit()`: fit statistics for multiple lavaan objects can be extracted.

A table of the description of all parameters that can be estimated is shown [here](#overview-of-estimated-lcs-model-parameters).

```{r}
# First create a lavaan object
bi_lcsm_01 <- fit_bi_lcsm(data = data_bi_lcsm, 
                          var_x = c("x1", "x2", "x3", "x4", "x5",
                                    "x6", "x7", "x8", "x9", "x10"),
                          var_y = c("y1", "y2", "y3", "y4", "y5", 
                                    "y6", "y7", "y8", "y9", "y10"),
                          model_x = list(alpha_constant = TRUE, 
                                         beta = TRUE, 
                                         phi = FALSE),
                          model_y = list(alpha_constant = TRUE, 
                                         beta = TRUE, 
                                         phi = TRUE),
                          coupling = list(delta_lag_xy = TRUE, 
                                          xi_lag_yx = TRUE))

# Now extract parameter estimates
# Only extract first 7 columns for this example by adding [ , 1:7]
param_bi_lcsm_01 <- extract_param(bi_lcsm_01)[ , 1:7]

# Print table of parameter estimates
kable(param_bi_lcsm_01, digits = 3)
```

### Plot simplified path diagrams of LCS models

This function is work in progress and can only plot univariate and bivariate LCS models that were specified with `fit_uni_lcsm()` or `fit_bi_lcsm()`.
Modified LCS models will probably return errors as the layout matrix that gets created by this plot function only supports the specifications that can be modelled with this package.
The input arguments for plotting a simplified path dioagram are: 

- the estimated lavaan object `lavaan_object`,
- the `lavaan_syntax` and ,
- `lcsm` indicating whether the LCS model is "univariate" or "bivariate"

Optional arguments can be used to change the look of the plot, for example:

- `lcsm_colours` can be used to highlight the different parts of the latent change score model
  - white: observed scores
  - green: latent true scores
  - blue: latent change scores
  - yellow: latent change scores

Further arguments can be passed on to `semPlot::semPaths()`, for example:

  - `what`, **"path"** to show unweighted gray edges, **"par"** to show parameter estimates as weighted (green/red) edges   
  - `whatLabels`, **"label"** to show edege names as label or **"est"** for parameter estimates, **"hide"** to hide edge labels

#### Univariate LCS model

```{r, fig.width = 6, fig.height = 4, dpi = 320}
# Fit bivariate lcsm and save the results 
uni_lavaan_results <- fit_uni_lcsm(data = data_uni_lcsm, 
                                   var = c("x1", "x2", "x3", "x4", "x5"),
                                   model = list(alpha_constant = TRUE, 
                                                beta = TRUE, 
                                                phi = TRUE)
                                  )

# Save the lavaan syntax that is used to create the layout matrix for semPlot
uni_lavaan_syntax <- fit_uni_lcsm(data = data_uni_lcsm, 
                                  var = c("x1", "x2", "x3", "x4", "x5"),
                                  model = list(alpha_constant = TRUE, 
                                               beta = TRUE, 
                                               phi = TRUE),
                                  return_lavaan_syntax = TRUE, 
                                  return_lavaan_syntax_string = TRUE)

# Plot the results
plot_lcsm(lavaan_object = uni_lavaan_results,
          lavaan_syntax = uni_lavaan_syntax,
          edge.label.cex = .9,  
          lcsm_colours = TRUE,
          lcsm = "univariate")

```

#### Bivariate LCS model

```{r, fig.width = 6, fig.height = 4, dpi = 320}
# Fit bivariate lcsm and save the results 
bi_lavaan_results <- fit_bi_lcsm(data = data_bi_lcsm, 
                                 var_x = c("x1", "x2", "x3", "x4", "x5"),
                                 var_y = c("y1", "y2", "y3", "y4", "y5"),
                                 model_x = list(alpha_constant = TRUE, 
                                                beta = TRUE, 
                                                phi = FALSE),
                                 model_y = list(alpha_constant = TRUE, 
                                                beta = TRUE, 
                                                phi = TRUE),
                                 coupling = list(delta_lag_xy = TRUE, 
                                                 xi_lag_yx = TRUE))

# Save the lavaan syntax that is used to create the layout matrix for semPlot
bi_lavaan_syntax <- fit_bi_lcsm(data = data_bi_lcsm, 
                                var_x = c("x1", "x2", "x3", "x4", "x5"),
                                var_y = c("y1", "y2", "y3", "y4", "y5"),
                                model_x = list(alpha_constant = TRUE, 
                                               beta = TRUE, 
                                               phi = FALSE),
                                model_y = list(alpha_constant = TRUE, 
                                               beta = TRUE, 
                                               phi = TRUE),
                                coupling = list(delta_lag_xy = TRUE, 
                                                xi_lag_yx = TRUE),
                                return_lavaan_syntax = TRUE, 
                                return_lavaan_syntax_string = TRUE)

# Plot the results
plot_lcsm(lavaan_object = bi_lavaan_results, 
          lavaan_syntax = bi_lavaan_syntax,
          lcsm_colours = TRUE,
          whatLabels = "hide",
          lcsm = "bivariate")

```


### Simulate data

The functions `sim_uni_lcsm()` and `sim_bi_lcsm()` simulate data based on some some parameters that can be specified.
See the tables [here](#overview-of-estimated-lcs-model-parameters) for a full list of parameters that can be specified for the data simulation.

```{r sim-uni-data}
# Simulate some data 
sim_uni_lcsm(timepoints = 5, 
             model = list(alpha_constant = TRUE, beta = FALSE, phi = TRUE), 
             model_param = list(gamma_lx1 = 21, 
                                sigma2_lx1 = 1.5,
                                sigma2_ux = 0.2,
                                alpha_j2 = -0.93,
                                sigma2_j2 = 0.1,
                                sigma_j2lx1 = 0.2,
                                phi_x = 0.3),
             sample.nobs = 1000,
             na_pct = 0.3)

```


It is also possible to return the lavaan syntax instead of simulating data for further manual specifications.
The modified object could then be used to simulate data using `lavaan::simulateData()`.

```{r, eval=FALSE}
# Return lavaan syntax based on the following argument specifications
simsyntax <- sim_bi_lcsm(timepoints = 5, 
                         model_x = list(alpha_constant = TRUE, beta = TRUE, phi = FALSE),
                         model_x_param = list(gamma_lx1 = 21,
                                              sigma2_lx1 = .5,
                                              sigma2_ux = .2,
                                              alpha_g2 = -.4,
                                              sigma2_g2 = .4,
                                              sigma_g2lx1 = .2,
                                              beta_x = -.1),
                         model_y = list(alpha_constant = TRUE, beta = TRUE, phi = TRUE),
                         model_y_param = list(gamma_ly1 = 5,
                                              sigma2_ly1 = .2,
                                              sigma2_uy = .2,
                                              alpha_j2 = -.2,
                                              sigma2_j2 = .1,
                                              sigma_j2ly1 = .02,
                                              beta_y = -.2,
                                              phi_y = .1),
                         coupling = list(delta_lag_xy = TRUE, 
                                         xi_lag_yx = TRUE),
                         coupling_param = list(sigma_su = .01,
                                               sigma_ly1lx1 = .2,
                                               sigma_g2ly1 = .1,
                                               sigma_j2lx1 = .1,
                                               sigma_j2g2 = .01,
                                               delta_lag_xy = .13,
                                               xi_lag_yx = .4),
                         return_lavaan_syntax = TRUE)
```


<details>
<summary>Click here to see the lavaan syntax specified in <code>simsyntax</code>.</summary>
<p>
```
# Specify parameters for construct x ----
# Specify latent true scores 
lx1 =~ 1 * x1 
lx2 =~ 1 * x2 
lx3 =~ 1 * x3 
lx4 =~ 1 * x4 
lx5 =~ 1 * x5 
# Specify mean of latent true scores 
lx1 ~ 21 * 1 
lx2 ~ 0 * 1 
lx3 ~ 0 * 1 
lx4 ~ 0 * 1 
lx5 ~ 0 * 1 
# Specify variance of latent true scores 
lx1 ~~ 0.5 * lx1 
lx2 ~~ 0 * lx2 
lx3 ~~ 0 * lx3 
lx4 ~~ 0 * lx4 
lx5 ~~ 0 * lx5 
# Specify intercept of obseved scores 
x1 ~ 0 * 1 
x2 ~ 0 * 1 
x3 ~ 0 * 1 
x4 ~ 0 * 1 
x5 ~ 0 * 1 
# Specify variance of observed scores 
x1 ~~ 0.2 * x1 
x2 ~~ 0.2 * x2 
x3 ~~ 0.2 * x3 
x4 ~~ 0.2 * x4 
x5 ~~ 0.2 * x5 
# Specify autoregressions of latent variables 
lx2 ~ 1 * lx1 
lx3 ~ 1 * lx2 
lx4 ~ 1 * lx3 
lx5 ~ 1 * lx4 
# Specify latent change scores 
dx2 =~ 1 * lx2 
dx3 =~ 1 * lx3 
dx4 =~ 1 * lx4 
dx5 =~ 1 * lx5 
# Specify latent change scores means 
dx2 ~ 0 * 1 
dx3 ~ 0 * 1 
dx4 ~ 0 * 1 
dx5 ~ 0 * 1 
# Specify latent change scores variances 
dx2 ~~ 0 * dx2 
dx3 ~~ 0 * dx3 
dx4 ~~ 0 * dx4 
dx5 ~~ 0 * dx5 
# Specify constant change factor 
g2 =~ 1 * dx2 + 1 * dx3 + 1 * dx4 + 1 * dx5 
# Specify constant change factor mean 
g2 ~ -0.4 * 1 
# Specify constant change factor variance 
g2 ~~ 0.4 * g2 
# Specify constant change factor covariance with the initial true score 
g2 ~~ 0.2 * lx1
# Specify proportional change component 
dx2 ~ -0.1 * lx1 
dx3 ~ -0.1 * lx2 
dx4 ~ -0.1 * lx3 
dx5 ~ -0.1 * lx4 
# Specify parameters for construct y ----
# Specify latent true scores 
ly1 =~ 1 * y1 
ly2 =~ 1 * y2 
ly3 =~ 1 * y3 
ly4 =~ 1 * y4 
ly5 =~ 1 * y5 
# Specify mean of latent true scores 
ly1 ~ 5 * 1 
ly2 ~ 0 * 1 
ly3 ~ 0 * 1 
ly4 ~ 0 * 1 
ly5 ~ 0 * 1 
# Specify variance of latent true scores 
ly1 ~~ 0.2 * ly1 
ly2 ~~ 0 * ly2 
ly3 ~~ 0 * ly3 
ly4 ~~ 0 * ly4 
ly5 ~~ 0 * ly5 
# Specify intercept of obseved scores 
y1 ~ 0 * 1 
y2 ~ 0 * 1 
y3 ~ 0 * 1 
y4 ~ 0 * 1 
y5 ~ 0 * 1 
# Specify variance of observed scores 
y1 ~~ 0.2 * y1 
y2 ~~ 0.2 * y2 
y3 ~~ 0.2 * y3 
y4 ~~ 0.2 * y4 
y5 ~~ 0.2 * y5 
# Specify autoregressions of latent variables 
ly2 ~ 1 * ly1 
ly3 ~ 1 * ly2 
ly4 ~ 1 * ly3 
ly5 ~ 1 * ly4 
# Specify latent change scores 
dy2 =~ 1 * ly2 
dy3 =~ 1 * ly3 
dy4 =~ 1 * ly4 
dy5 =~ 1 * ly5 
# Specify latent change scores means 
dy2 ~ 0 * 1 
dy3 ~ 0 * 1 
dy4 ~ 0 * 1 
dy5 ~ 0 * 1 
# Specify latent change scores variances 
dy2 ~~ 0 * dy2 
dy3 ~~ 0 * dy3 
dy4 ~~ 0 * dy4 
dy5 ~~ 0 * dy5 
# Specify constant change factor 
j2 =~ 1 * dy2 + 1 * dy3 + 1 * dy4 + 1 * dy5 
# Specify constant change factor mean 
j2 ~ -0.2 * 1 
# Specify constant change factor variance 
j2 ~~ 0.1 * j2 
# Specify constant change factor covariance with the initial true score 
j2 ~~ 0.02 * ly1
# Specify proportional change component 
dy2 ~ -0.2 * ly1 
dy3 ~ -0.2 * ly2 
dy4 ~ -0.2 * ly3 
dy5 ~ -0.2 * ly4 
# Specify autoregression of change score 
dy3 ~ 0.1 * dy2 
dy4 ~ 0.1 * dy3 
dy5 ~ 0.1 * dy4 
# Specify residual covariances 
x1 ~~ 0.01 * y1 
x2 ~~ 0.01 * y2 
x3 ~~ 0.01 * y3 
x4 ~~ 0.01 * y4 
x5 ~~ 0.01 * y5 
# Specify covariances betweeen specified change components (alpha) and intercepts (initial latent true scores lx1 and ly1) ----
# Specify covariance of intercepts 
lx1 ~~ 0.2 * ly1 
# Specify covariance of constant change and intercept within the same construct 
ly1 ~~ 0.1 * g2 
# Specify covariance of constant change and intercept within the same construct 
lx1 ~~ 0.1 * j2 
# Specify covariance of constant change factors between constructs 
g2 ~~ 0.01 * j2 
# Specify between-construct coupling parameters ----
# Change score x (t) is determined by true score y (t-1)  
dx2 ~ 0.13 * ly1 
dx3 ~ 0.13 * ly2 
dx4 ~ 0.13 * ly3 
dx5 ~ 0.13 * ly4 
# Change score y (t) is determined by change score x (t-1)  
dy3 ~ 0.4 * dx2 
dy4 ~ 0.4 * dx3 
dy5 ~ 0.4 * dx4 
```
</p>
</details>


## Overview of estimated LCS model parameters

### Univariate LCS models

Depending on the specified model, the following parameters can be estimated for **univariate** LCS models: 

|Parameter   |Description                                                             |
|:-----------|:-----------------------------------------------------------------------|
|gamma_lx1   |Mean of latent true scores x (Intercept)                                |
|sigma2_lx1  |Variance of latent true scores x                                        |
|sigma2_ux   |Variance of observed scores x                                           |
|alpha_g2    |Mean of change factor (g2)                                              |
|alpha_g3    |Mean of change factor (g3)                                              |
|sigma2_g2   |Variance of change factor (g2)                                          |
|sigma2_g3   |Variance of change factor (g3)                                          |
|sigma_g2lx1 |Covariance of change factor (g2) with the initial true score x          |
|sigma_g3lx1 |Covariance of change factor (g3) with the initial true score x          |
|sigma_g2g3  |Covariance of change factors within construct x                         |
|beta\_x     | Proportional change x                                                  |
|phi_x       |Autoregression of change scores x                                       |

### Bivariate LCS models

For bivariate LCS models, estimated parameters can be categorised into (1) **Construct X**, (2) **Construct Y**, and (3) **Coupling between X and Y**.

|Parameter    |Description                                                             |
|:------------|:-----------------------------------------------------------------------|
|**Construct X**                                                                       |
|gamma_lx1    |Mean of latent true scores x (Intercept)                                |
|sigma2_lx1   |Variance of latent true scores x                                        |
|sigma2_ux    |Variance of observed scores x                                           |
|alpha_g2     |Mean of change factor (g2)                                              |
|alpha_g3     |Mean of change factor (g3)                                              |
|sigma2_g2    |Variance of change factor (g2)                                          |
|sigma2_g3    |Variance of change factor (g3)                                          |
| beta\_x     | Proportional change x                                                  |
|sigma_g2lx1  |Covariance of change factor (g2) with the initial true score x (lx1)    |
|sigma_g3lx1  |Covariance of change factor (g3) with the initial true score x (lx1)    |
|sigma_g2g3   |Covariance of change factors within construct x                         |
|phi_x        |Autoregression of change scores x                                       |
|**Construct Y**                                                                       |
|gamma_ly1    |Mean of latent true scores y (Intercept)                                |
|sigma2_ly1   |Variance of latent true scores y                                        |
|sigma2_uy    |Variance of observed scores y                                           |
|alpha_j2     |Mean of change factor (j2)                                              |
|alpha_j3     |Mean of change factor (j3)                                              |
|sigma2_j2    |Variance of change factor (j2)                                          |
|sigma2_j3    |Variance of change factor (j3)                                          |
| beta\_y     | Proportional change y                                                  |
|sigma_j2ly1  |Covariance of change factor (j2) with the initial true score y (ly1)    |
|sigma_j3ly1  |Covariance of change factor (j3) with the initial true score y (ly1)    |
|sigma_j2j3   |Covariance of change factors within construct y                         |
|phi_y        |Autoregression of change scores y                                       |
|**Coupeling X & Y**                                                                   |
|sigma_su     |Covariance of residuals x and y                                         |
|sigma_ly1lx1 |Covariance of intercepts x and y                                        |
|sigma_g2ly1  |Covariance of change factor x (g2) with the initial true score y (ly1)  |
|sigma_g3ly1  |Covariance of change factor x (g3) with the initial true score y (ly1)  |
|sigma_j2lx1  |Covariance of change factor y (j2) with the initial true score x (lx1)  |
|sigma_j3lx1  |Covariance of change factor y (j3) with the initial true score x (lx1)  |
|sigma_j2g2   |Covariance of change factors y (j2) and x (g2)                          |
|sigma_j2g3   | Covariance of change factors y (j2) and x (g3)                         |
|sigma_j3g2   |Covariance of change factors y (j3) and x (g2)                          |
|delta_con_xy |Change score x (t) determined by true score y (t)                       |
|delta_con_yx |Change score y (t) determined by true score x (t)                       |
|delta_lag_xy |Change score x (t) determined by true score y (t-1)                     |
|delta_lag_yx |Change score y (t) determined by true score x (t-1)                     |
|xi_con_xy    |Change score x (t) determined by change score y (t)                     |
|xi_con_yx    |Change score y (t) determined by change score x (t)                     |
|xi_lag_xy    |Change score x (t) determined by change score y (t-1)                   |
|xi_lag_yx    |Change score y (t) determined by change score x (t-1)                   |
